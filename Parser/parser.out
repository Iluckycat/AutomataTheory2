Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ANY

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     command -> CMD DIRECT
Rule 3     statements -> statements statement
Rule 4     statements -> statement
Rule 5     statement -> empty eoe
Rule 6     statement -> variable eoe
Rule 7     statement -> assignment eoe
Rule 8     statement -> from eoe
Rule 9     statement -> if eoe
Rule 10    statement -> function eoe
Rule 11    statement -> function_call eoe
Rule 12    statement -> command eoe
Rule 13    eoe -> NEWLINE
Rule 14    eoe -> SEMICOLON
Rule 15    eoe -> SEMICOLON NEWLINE
Rule 16    empty -> <empty>
Rule 17    assignment -> variable ASSIGNMENT expression
Rule 18    variable -> NAME index
Rule 19    variable -> NAME LBRACKET index RBRACKET
Rule 20    index -> <empty>
Rule 21    index -> index COMMA INT
Rule 22    index -> INT
Rule 23    expression -> variable
Rule 24    expression -> const
Rule 25    expression -> operation
Rule 26    expression -> logic_expr
Rule 27    expression -> function_call
Rule 28    const -> INT
Rule 29    const -> FLOAT
Rule 30    const -> BOOL
Rule 31    const -> CELLTYPE
Rule 32    operation -> expression PLUS expression
Rule 33    operation -> expression MINUS expression
Rule 34    operation -> MINUS expression
Rule 35    from -> FROM expression TO expression DO FUNCTION NEWLINE statements END
Rule 36    from -> FROM expression TO expression function_call
Rule 37    from -> FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
Rule 38    from -> FROM expression TO expression WITH STEP expression function_call
Rule 39    function_call -> DO NAME
Rule 40    if -> IF logic_expr function_call
Rule 41    if -> IF logic_expr DO FUNCTION NEWLINE statements END
Rule 42    logic_expr -> expression AND expression
Rule 43    logic_expr -> expression OR expression
Rule 44    logic_expr -> expression CMP expression
Rule 45    function -> FUNCTION NAME NEWLINE statements END
Rule 46    assignment -> variable ASSIGNMENT error
Rule 47    from -> FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
Rule 48    from -> FROM expression TO expression DO FUNCTION error statements END
Rule 49    from -> FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
Rule 50    from -> FROM expression error expression DO FUNCTION NEWLINE statements END
Rule 51    from -> FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
Rule 52    from -> FROM expression TO expression DO error NEWLINE statements END
Rule 53    from -> FROM expression TO expression error FUNCTION NEWLINE statements END
Rule 54    from -> FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
Rule 55    if -> IF logic_expr DO FUNCTION error statements END
Rule 56    if -> IF logic_expr DO error NEWLINE statements END
Rule 57    if -> IF error DO FUNCTION NEWLINE statements END
Rule 58    if -> IF error function_call
Rule 59    if -> IF logic_expr error FUNCTION NEWLINE statements END
Rule 60    function -> FUNCTION NAME error statements END
Rule 61    function -> error NAME NEWLINE statements END

Terminals, with rules where they appear

AND                  : 42
ANY                  : 
ASSIGNMENT           : 17 46
BOOL                 : 30
CELLTYPE             : 31
CMD                  : 2
CMP                  : 44
COMMA                : 21
DIRECT               : 2
DO                   : 35 37 39 41 47 48 49 50 51 52 55 56 57
END                  : 35 37 41 45 47 48 49 50 51 52 53 54 55 56 57 59 60 61
FLOAT                : 29
FROM                 : 35 36 37 38 47 48 49 50 51 52 53 54
FUNCTION             : 35 37 41 45 47 48 49 50 53 54 55 57 59 60
IF                   : 40 41 55 56 57 58 59
INT                  : 21 22 28
LBRACKET             : 19
MINUS                : 33 34
NAME                 : 18 19 39 45 60 61
NEWLINE              : 13 15 35 37 41 45 49 50 51 52 53 54 56 57 59 61
OR                   : 43
PLUS                 : 32
RBRACKET             : 19
SEMICOLON            : 14 15
STEP                 : 37 38 47 49 51 54
TO                   : 35 36 37 38 47 48 51 52 53 54
WITH                 : 37 38 47 49 51 54
error                : 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61

Nonterminals, with rules where they appear

assignment           : 7
command              : 12
const                : 24
empty                : 5
eoe                  : 5 6 7 8 9 10 11 12
expression           : 17 32 32 33 33 34 35 35 36 36 37 37 37 38 38 38 42 42 43 43 44 44 47 47 47 48 48 49 49 49 50 50 51 51 51 52 52 53 53 54 54 54
from                 : 8
function             : 10
function_call        : 11 27 36 38 40 58
if                   : 9
index                : 18 19 21
logic_expr           : 26 40 41 55 56 59
operation            : 25
program              : 0
statement            : 3 4
statements           : 1 3 35 37 41 45 47 48 49 50 51 52 53 54 55 56 57 59 60 61
variable             : 6 17 23 46

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 1

    (0) S' -> program .



state 2

    (1) program -> statements .
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    $end            reduce using rule 1 (program -> statements .)
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 3

    (4) statements -> statement .

    NAME            reduce using rule 4 (statements -> statement .)
    FROM            reduce using rule 4 (statements -> statement .)
    IF              reduce using rule 4 (statements -> statement .)
    FUNCTION        reduce using rule 4 (statements -> statement .)
    error           reduce using rule 4 (statements -> statement .)
    DO              reduce using rule 4 (statements -> statement .)
    CMD             reduce using rule 4 (statements -> statement .)
    NEWLINE         reduce using rule 4 (statements -> statement .)
    SEMICOLON       reduce using rule 4 (statements -> statement .)
    $end            reduce using rule 4 (statements -> statement .)
    END             reduce using rule 4 (statements -> statement .)


state 4

    (5) statement -> empty . eoe
    (13) eoe -> . NEWLINE
    (14) eoe -> . SEMICOLON
    (15) eoe -> . SEMICOLON NEWLINE

    NEWLINE         shift and go to state 21
    SEMICOLON       shift and go to state 22

    eoe                            shift and go to state 20

state 5

    (6) statement -> variable . eoe
    (17) assignment -> variable . ASSIGNMENT expression
    (46) assignment -> variable . ASSIGNMENT error
    (13) eoe -> . NEWLINE
    (14) eoe -> . SEMICOLON
    (15) eoe -> . SEMICOLON NEWLINE

    ASSIGNMENT      shift and go to state 24
    NEWLINE         shift and go to state 21
    SEMICOLON       shift and go to state 22

    eoe                            shift and go to state 23

state 6

    (7) statement -> assignment . eoe
    (13) eoe -> . NEWLINE
    (14) eoe -> . SEMICOLON
    (15) eoe -> . SEMICOLON NEWLINE

    NEWLINE         shift and go to state 21
    SEMICOLON       shift and go to state 22

    eoe                            shift and go to state 25

state 7

    (8) statement -> from . eoe
    (13) eoe -> . NEWLINE
    (14) eoe -> . SEMICOLON
    (15) eoe -> . SEMICOLON NEWLINE

    NEWLINE         shift and go to state 21
    SEMICOLON       shift and go to state 22

    eoe                            shift and go to state 26

state 8

    (9) statement -> if . eoe
    (13) eoe -> . NEWLINE
    (14) eoe -> . SEMICOLON
    (15) eoe -> . SEMICOLON NEWLINE

    NEWLINE         shift and go to state 21
    SEMICOLON       shift and go to state 22

    eoe                            shift and go to state 27

state 9

    (10) statement -> function . eoe
    (13) eoe -> . NEWLINE
    (14) eoe -> . SEMICOLON
    (15) eoe -> . SEMICOLON NEWLINE

    NEWLINE         shift and go to state 21
    SEMICOLON       shift and go to state 22

    eoe                            shift and go to state 28

state 10

    (11) statement -> function_call . eoe
    (13) eoe -> . NEWLINE
    (14) eoe -> . SEMICOLON
    (15) eoe -> . SEMICOLON NEWLINE

    NEWLINE         shift and go to state 21
    SEMICOLON       shift and go to state 22

    eoe                            shift and go to state 29

state 11

    (12) statement -> command . eoe
    (13) eoe -> . NEWLINE
    (14) eoe -> . SEMICOLON
    (15) eoe -> . SEMICOLON NEWLINE

    NEWLINE         shift and go to state 21
    SEMICOLON       shift and go to state 22

    eoe                            shift and go to state 30

state 12

    (18) variable -> NAME . index
    (19) variable -> NAME . LBRACKET index RBRACKET
    (20) index -> .
    (21) index -> . index COMMA INT
    (22) index -> . INT

    LBRACKET        shift and go to state 32
    COMMA           reduce using rule 20 (index -> .)
    ASSIGNMENT      reduce using rule 20 (index -> .)
    NEWLINE         reduce using rule 20 (index -> .)
    SEMICOLON       reduce using rule 20 (index -> .)
    TO              reduce using rule 20 (index -> .)
    error           reduce using rule 20 (index -> .)
    PLUS            reduce using rule 20 (index -> .)
    MINUS           reduce using rule 20 (index -> .)
    AND             reduce using rule 20 (index -> .)
    OR              reduce using rule 20 (index -> .)
    CMP             reduce using rule 20 (index -> .)
    DO              reduce using rule 20 (index -> .)
    WITH            reduce using rule 20 (index -> .)
    INT             shift and go to state 33

    index                          shift and go to state 31

state 13

    (61) function -> error . NAME NEWLINE statements END

    NAME            shift and go to state 34


state 14

    (35) from -> FROM . expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> FROM . expression TO expression function_call
    (37) from -> FROM . expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> FROM . expression TO expression WITH STEP expression function_call
    (47) from -> FROM . expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> FROM . expression TO expression DO FUNCTION error statements END
    (49) from -> FROM . expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> FROM . expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> FROM . expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> FROM . expression TO expression DO error NEWLINE statements END
    (53) from -> FROM . expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> FROM . expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (23) expression -> . variable
    (24) expression -> . const
    (25) expression -> . operation
    (26) expression -> . logic_expr
    (27) expression -> . function_call
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (28) const -> . INT
    (29) const -> . FLOAT
    (30) const -> . BOOL
    (31) const -> . CELLTYPE
    (32) operation -> . expression PLUS expression
    (33) operation -> . expression MINUS expression
    (34) operation -> . MINUS expression
    (42) logic_expr -> . expression AND expression
    (43) logic_expr -> . expression OR expression
    (44) logic_expr -> . expression CMP expression
    (39) function_call -> . DO NAME

    NAME            shift and go to state 12
    INT             shift and go to state 41
    FLOAT           shift and go to state 42
    BOOL            shift and go to state 43
    CELLTYPE        shift and go to state 44
    MINUS           shift and go to state 45
    DO              shift and go to state 15

    expression                     shift and go to state 35
    function_call                  shift and go to state 36
    variable                       shift and go to state 37
    const                          shift and go to state 38
    operation                      shift and go to state 39
    logic_expr                     shift and go to state 40

state 15

    (39) function_call -> DO . NAME

    NAME            shift and go to state 46


state 16

    (45) function -> FUNCTION . NAME NEWLINE statements END
    (60) function -> FUNCTION . NAME error statements END

    NAME            shift and go to state 47


state 17

    (40) if -> IF . logic_expr function_call
    (41) if -> IF . logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> IF . logic_expr DO FUNCTION error statements END
    (56) if -> IF . logic_expr DO error NEWLINE statements END
    (57) if -> IF . error DO FUNCTION NEWLINE statements END
    (58) if -> IF . error function_call
    (59) if -> IF . logic_expr error FUNCTION NEWLINE statements END
    (42) logic_expr -> . expression AND expression
    (43) logic_expr -> . expression OR expression
    (44) logic_expr -> . expression CMP expression
    (23) expression -> . variable
    (24) expression -> . const
    (25) expression -> . operation
    (26) expression -> . logic_expr
    (27) expression -> . function_call
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (28) const -> . INT
    (29) const -> . FLOAT
    (30) const -> . BOOL
    (31) const -> . CELLTYPE
    (32) operation -> . expression PLUS expression
    (33) operation -> . expression MINUS expression
    (34) operation -> . MINUS expression
    (39) function_call -> . DO NAME

    error           shift and go to state 49
    NAME            shift and go to state 12
    INT             shift and go to state 41
    FLOAT           shift and go to state 42
    BOOL            shift and go to state 43
    CELLTYPE        shift and go to state 44
    MINUS           shift and go to state 45
    DO              shift and go to state 15

    logic_expr                     shift and go to state 48
    function_call                  shift and go to state 36
    expression                     shift and go to state 50
    variable                       shift and go to state 37
    const                          shift and go to state 38
    operation                      shift and go to state 39

state 18

    (2) command -> CMD . DIRECT

    DIRECT          shift and go to state 51


state 19

    (3) statements -> statements statement .

    NAME            reduce using rule 3 (statements -> statements statement .)
    FROM            reduce using rule 3 (statements -> statements statement .)
    IF              reduce using rule 3 (statements -> statements statement .)
    FUNCTION        reduce using rule 3 (statements -> statements statement .)
    error           reduce using rule 3 (statements -> statements statement .)
    DO              reduce using rule 3 (statements -> statements statement .)
    CMD             reduce using rule 3 (statements -> statements statement .)
    NEWLINE         reduce using rule 3 (statements -> statements statement .)
    SEMICOLON       reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)
    END             reduce using rule 3 (statements -> statements statement .)


state 20

    (5) statement -> empty eoe .

    NAME            reduce using rule 5 (statement -> empty eoe .)
    FROM            reduce using rule 5 (statement -> empty eoe .)
    IF              reduce using rule 5 (statement -> empty eoe .)
    FUNCTION        reduce using rule 5 (statement -> empty eoe .)
    error           reduce using rule 5 (statement -> empty eoe .)
    DO              reduce using rule 5 (statement -> empty eoe .)
    CMD             reduce using rule 5 (statement -> empty eoe .)
    NEWLINE         reduce using rule 5 (statement -> empty eoe .)
    SEMICOLON       reduce using rule 5 (statement -> empty eoe .)
    $end            reduce using rule 5 (statement -> empty eoe .)
    END             reduce using rule 5 (statement -> empty eoe .)


state 21

    (13) eoe -> NEWLINE .

    NAME            reduce using rule 13 (eoe -> NEWLINE .)
    FROM            reduce using rule 13 (eoe -> NEWLINE .)
    IF              reduce using rule 13 (eoe -> NEWLINE .)
    FUNCTION        reduce using rule 13 (eoe -> NEWLINE .)
    error           reduce using rule 13 (eoe -> NEWLINE .)
    DO              reduce using rule 13 (eoe -> NEWLINE .)
    CMD             reduce using rule 13 (eoe -> NEWLINE .)
    NEWLINE         reduce using rule 13 (eoe -> NEWLINE .)
    SEMICOLON       reduce using rule 13 (eoe -> NEWLINE .)
    $end            reduce using rule 13 (eoe -> NEWLINE .)
    END             reduce using rule 13 (eoe -> NEWLINE .)


state 22

    (14) eoe -> SEMICOLON .
    (15) eoe -> SEMICOLON . NEWLINE

  ! shift/reduce conflict for NEWLINE resolved as shift
    NAME            reduce using rule 14 (eoe -> SEMICOLON .)
    FROM            reduce using rule 14 (eoe -> SEMICOLON .)
    IF              reduce using rule 14 (eoe -> SEMICOLON .)
    FUNCTION        reduce using rule 14 (eoe -> SEMICOLON .)
    error           reduce using rule 14 (eoe -> SEMICOLON .)
    DO              reduce using rule 14 (eoe -> SEMICOLON .)
    CMD             reduce using rule 14 (eoe -> SEMICOLON .)
    SEMICOLON       reduce using rule 14 (eoe -> SEMICOLON .)
    $end            reduce using rule 14 (eoe -> SEMICOLON .)
    END             reduce using rule 14 (eoe -> SEMICOLON .)
    NEWLINE         shift and go to state 52

  ! NEWLINE         [ reduce using rule 14 (eoe -> SEMICOLON .) ]


state 23

    (6) statement -> variable eoe .

    NAME            reduce using rule 6 (statement -> variable eoe .)
    FROM            reduce using rule 6 (statement -> variable eoe .)
    IF              reduce using rule 6 (statement -> variable eoe .)
    FUNCTION        reduce using rule 6 (statement -> variable eoe .)
    error           reduce using rule 6 (statement -> variable eoe .)
    DO              reduce using rule 6 (statement -> variable eoe .)
    CMD             reduce using rule 6 (statement -> variable eoe .)
    NEWLINE         reduce using rule 6 (statement -> variable eoe .)
    SEMICOLON       reduce using rule 6 (statement -> variable eoe .)
    $end            reduce using rule 6 (statement -> variable eoe .)
    END             reduce using rule 6 (statement -> variable eoe .)


state 24

    (17) assignment -> variable ASSIGNMENT . expression
    (46) assignment -> variable ASSIGNMENT . error
    (23) expression -> . variable
    (24) expression -> . const
    (25) expression -> . operation
    (26) expression -> . logic_expr
    (27) expression -> . function_call
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (28) const -> . INT
    (29) const -> . FLOAT
    (30) const -> . BOOL
    (31) const -> . CELLTYPE
    (32) operation -> . expression PLUS expression
    (33) operation -> . expression MINUS expression
    (34) operation -> . MINUS expression
    (42) logic_expr -> . expression AND expression
    (43) logic_expr -> . expression OR expression
    (44) logic_expr -> . expression CMP expression
    (39) function_call -> . DO NAME

    error           shift and go to state 54
    NAME            shift and go to state 12
    INT             shift and go to state 41
    FLOAT           shift and go to state 42
    BOOL            shift and go to state 43
    CELLTYPE        shift and go to state 44
    MINUS           shift and go to state 45
    DO              shift and go to state 15

    variable                       shift and go to state 37
    expression                     shift and go to state 53
    const                          shift and go to state 38
    operation                      shift and go to state 39
    logic_expr                     shift and go to state 40
    function_call                  shift and go to state 36

state 25

    (7) statement -> assignment eoe .

    NAME            reduce using rule 7 (statement -> assignment eoe .)
    FROM            reduce using rule 7 (statement -> assignment eoe .)
    IF              reduce using rule 7 (statement -> assignment eoe .)
    FUNCTION        reduce using rule 7 (statement -> assignment eoe .)
    error           reduce using rule 7 (statement -> assignment eoe .)
    DO              reduce using rule 7 (statement -> assignment eoe .)
    CMD             reduce using rule 7 (statement -> assignment eoe .)
    NEWLINE         reduce using rule 7 (statement -> assignment eoe .)
    SEMICOLON       reduce using rule 7 (statement -> assignment eoe .)
    $end            reduce using rule 7 (statement -> assignment eoe .)
    END             reduce using rule 7 (statement -> assignment eoe .)


state 26

    (8) statement -> from eoe .

    NAME            reduce using rule 8 (statement -> from eoe .)
    FROM            reduce using rule 8 (statement -> from eoe .)
    IF              reduce using rule 8 (statement -> from eoe .)
    FUNCTION        reduce using rule 8 (statement -> from eoe .)
    error           reduce using rule 8 (statement -> from eoe .)
    DO              reduce using rule 8 (statement -> from eoe .)
    CMD             reduce using rule 8 (statement -> from eoe .)
    NEWLINE         reduce using rule 8 (statement -> from eoe .)
    SEMICOLON       reduce using rule 8 (statement -> from eoe .)
    $end            reduce using rule 8 (statement -> from eoe .)
    END             reduce using rule 8 (statement -> from eoe .)


state 27

    (9) statement -> if eoe .

    NAME            reduce using rule 9 (statement -> if eoe .)
    FROM            reduce using rule 9 (statement -> if eoe .)
    IF              reduce using rule 9 (statement -> if eoe .)
    FUNCTION        reduce using rule 9 (statement -> if eoe .)
    error           reduce using rule 9 (statement -> if eoe .)
    DO              reduce using rule 9 (statement -> if eoe .)
    CMD             reduce using rule 9 (statement -> if eoe .)
    NEWLINE         reduce using rule 9 (statement -> if eoe .)
    SEMICOLON       reduce using rule 9 (statement -> if eoe .)
    $end            reduce using rule 9 (statement -> if eoe .)
    END             reduce using rule 9 (statement -> if eoe .)


state 28

    (10) statement -> function eoe .

    NAME            reduce using rule 10 (statement -> function eoe .)
    FROM            reduce using rule 10 (statement -> function eoe .)
    IF              reduce using rule 10 (statement -> function eoe .)
    FUNCTION        reduce using rule 10 (statement -> function eoe .)
    error           reduce using rule 10 (statement -> function eoe .)
    DO              reduce using rule 10 (statement -> function eoe .)
    CMD             reduce using rule 10 (statement -> function eoe .)
    NEWLINE         reduce using rule 10 (statement -> function eoe .)
    SEMICOLON       reduce using rule 10 (statement -> function eoe .)
    $end            reduce using rule 10 (statement -> function eoe .)
    END             reduce using rule 10 (statement -> function eoe .)


state 29

    (11) statement -> function_call eoe .

    NAME            reduce using rule 11 (statement -> function_call eoe .)
    FROM            reduce using rule 11 (statement -> function_call eoe .)
    IF              reduce using rule 11 (statement -> function_call eoe .)
    FUNCTION        reduce using rule 11 (statement -> function_call eoe .)
    error           reduce using rule 11 (statement -> function_call eoe .)
    DO              reduce using rule 11 (statement -> function_call eoe .)
    CMD             reduce using rule 11 (statement -> function_call eoe .)
    NEWLINE         reduce using rule 11 (statement -> function_call eoe .)
    SEMICOLON       reduce using rule 11 (statement -> function_call eoe .)
    $end            reduce using rule 11 (statement -> function_call eoe .)
    END             reduce using rule 11 (statement -> function_call eoe .)


state 30

    (12) statement -> command eoe .

    NAME            reduce using rule 12 (statement -> command eoe .)
    FROM            reduce using rule 12 (statement -> command eoe .)
    IF              reduce using rule 12 (statement -> command eoe .)
    FUNCTION        reduce using rule 12 (statement -> command eoe .)
    error           reduce using rule 12 (statement -> command eoe .)
    DO              reduce using rule 12 (statement -> command eoe .)
    CMD             reduce using rule 12 (statement -> command eoe .)
    NEWLINE         reduce using rule 12 (statement -> command eoe .)
    SEMICOLON       reduce using rule 12 (statement -> command eoe .)
    $end            reduce using rule 12 (statement -> command eoe .)
    END             reduce using rule 12 (statement -> command eoe .)


state 31

    (18) variable -> NAME index .
    (21) index -> index . COMMA INT

    ASSIGNMENT      reduce using rule 18 (variable -> NAME index .)
    NEWLINE         reduce using rule 18 (variable -> NAME index .)
    SEMICOLON       reduce using rule 18 (variable -> NAME index .)
    TO              reduce using rule 18 (variable -> NAME index .)
    error           reduce using rule 18 (variable -> NAME index .)
    PLUS            reduce using rule 18 (variable -> NAME index .)
    MINUS           reduce using rule 18 (variable -> NAME index .)
    AND             reduce using rule 18 (variable -> NAME index .)
    OR              reduce using rule 18 (variable -> NAME index .)
    CMP             reduce using rule 18 (variable -> NAME index .)
    DO              reduce using rule 18 (variable -> NAME index .)
    WITH            reduce using rule 18 (variable -> NAME index .)
    COMMA           shift and go to state 55


state 32

    (19) variable -> NAME LBRACKET . index RBRACKET
    (20) index -> .
    (21) index -> . index COMMA INT
    (22) index -> . INT

    RBRACKET        reduce using rule 20 (index -> .)
    COMMA           reduce using rule 20 (index -> .)
    INT             shift and go to state 33

    index                          shift and go to state 56

state 33

    (22) index -> INT .

    COMMA           reduce using rule 22 (index -> INT .)
    ASSIGNMENT      reduce using rule 22 (index -> INT .)
    NEWLINE         reduce using rule 22 (index -> INT .)
    SEMICOLON       reduce using rule 22 (index -> INT .)
    TO              reduce using rule 22 (index -> INT .)
    error           reduce using rule 22 (index -> INT .)
    PLUS            reduce using rule 22 (index -> INT .)
    MINUS           reduce using rule 22 (index -> INT .)
    AND             reduce using rule 22 (index -> INT .)
    OR              reduce using rule 22 (index -> INT .)
    CMP             reduce using rule 22 (index -> INT .)
    DO              reduce using rule 22 (index -> INT .)
    WITH            reduce using rule 22 (index -> INT .)
    RBRACKET        reduce using rule 22 (index -> INT .)


state 34

    (61) function -> error NAME . NEWLINE statements END

    NEWLINE         shift and go to state 57


state 35

    (35) from -> FROM expression . TO expression DO FUNCTION NEWLINE statements END
    (36) from -> FROM expression . TO expression function_call
    (37) from -> FROM expression . TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> FROM expression . TO expression WITH STEP expression function_call
    (47) from -> FROM expression . TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> FROM expression . TO expression DO FUNCTION error statements END
    (49) from -> FROM expression . error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> FROM expression . error expression DO FUNCTION NEWLINE statements END
    (51) from -> FROM expression . TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> FROM expression . TO expression DO error NEWLINE statements END
    (53) from -> FROM expression . TO expression error FUNCTION NEWLINE statements END
    (54) from -> FROM expression . TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (32) operation -> expression . PLUS expression
    (33) operation -> expression . MINUS expression
    (42) logic_expr -> expression . AND expression
    (43) logic_expr -> expression . OR expression
    (44) logic_expr -> expression . CMP expression

    TO              shift and go to state 58
    error           shift and go to state 59
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    CMP             shift and go to state 64


state 36

    (27) expression -> function_call .

    TO              reduce using rule 27 (expression -> function_call .)
    error           reduce using rule 27 (expression -> function_call .)
    PLUS            reduce using rule 27 (expression -> function_call .)
    MINUS           reduce using rule 27 (expression -> function_call .)
    AND             reduce using rule 27 (expression -> function_call .)
    OR              reduce using rule 27 (expression -> function_call .)
    CMP             reduce using rule 27 (expression -> function_call .)
    NEWLINE         reduce using rule 27 (expression -> function_call .)
    SEMICOLON       reduce using rule 27 (expression -> function_call .)
    DO              reduce using rule 27 (expression -> function_call .)
    WITH            reduce using rule 27 (expression -> function_call .)


state 37

    (23) expression -> variable .

    TO              reduce using rule 23 (expression -> variable .)
    error           reduce using rule 23 (expression -> variable .)
    PLUS            reduce using rule 23 (expression -> variable .)
    MINUS           reduce using rule 23 (expression -> variable .)
    AND             reduce using rule 23 (expression -> variable .)
    OR              reduce using rule 23 (expression -> variable .)
    CMP             reduce using rule 23 (expression -> variable .)
    NEWLINE         reduce using rule 23 (expression -> variable .)
    SEMICOLON       reduce using rule 23 (expression -> variable .)
    DO              reduce using rule 23 (expression -> variable .)
    WITH            reduce using rule 23 (expression -> variable .)


state 38

    (24) expression -> const .

    TO              reduce using rule 24 (expression -> const .)
    error           reduce using rule 24 (expression -> const .)
    PLUS            reduce using rule 24 (expression -> const .)
    MINUS           reduce using rule 24 (expression -> const .)
    AND             reduce using rule 24 (expression -> const .)
    OR              reduce using rule 24 (expression -> const .)
    CMP             reduce using rule 24 (expression -> const .)
    NEWLINE         reduce using rule 24 (expression -> const .)
    SEMICOLON       reduce using rule 24 (expression -> const .)
    DO              reduce using rule 24 (expression -> const .)
    WITH            reduce using rule 24 (expression -> const .)


state 39

    (25) expression -> operation .

    TO              reduce using rule 25 (expression -> operation .)
    error           reduce using rule 25 (expression -> operation .)
    PLUS            reduce using rule 25 (expression -> operation .)
    MINUS           reduce using rule 25 (expression -> operation .)
    AND             reduce using rule 25 (expression -> operation .)
    OR              reduce using rule 25 (expression -> operation .)
    CMP             reduce using rule 25 (expression -> operation .)
    NEWLINE         reduce using rule 25 (expression -> operation .)
    SEMICOLON       reduce using rule 25 (expression -> operation .)
    DO              reduce using rule 25 (expression -> operation .)
    WITH            reduce using rule 25 (expression -> operation .)


state 40

    (26) expression -> logic_expr .

    TO              reduce using rule 26 (expression -> logic_expr .)
    error           reduce using rule 26 (expression -> logic_expr .)
    PLUS            reduce using rule 26 (expression -> logic_expr .)
    MINUS           reduce using rule 26 (expression -> logic_expr .)
    AND             reduce using rule 26 (expression -> logic_expr .)
    OR              reduce using rule 26 (expression -> logic_expr .)
    CMP             reduce using rule 26 (expression -> logic_expr .)
    NEWLINE         reduce using rule 26 (expression -> logic_expr .)
    SEMICOLON       reduce using rule 26 (expression -> logic_expr .)
    DO              reduce using rule 26 (expression -> logic_expr .)
    WITH            reduce using rule 26 (expression -> logic_expr .)


state 41

    (28) const -> INT .

    TO              reduce using rule 28 (const -> INT .)
    error           reduce using rule 28 (const -> INT .)
    PLUS            reduce using rule 28 (const -> INT .)
    MINUS           reduce using rule 28 (const -> INT .)
    AND             reduce using rule 28 (const -> INT .)
    OR              reduce using rule 28 (const -> INT .)
    CMP             reduce using rule 28 (const -> INT .)
    NEWLINE         reduce using rule 28 (const -> INT .)
    SEMICOLON       reduce using rule 28 (const -> INT .)
    DO              reduce using rule 28 (const -> INT .)
    WITH            reduce using rule 28 (const -> INT .)


state 42

    (29) const -> FLOAT .

    TO              reduce using rule 29 (const -> FLOAT .)
    error           reduce using rule 29 (const -> FLOAT .)
    PLUS            reduce using rule 29 (const -> FLOAT .)
    MINUS           reduce using rule 29 (const -> FLOAT .)
    AND             reduce using rule 29 (const -> FLOAT .)
    OR              reduce using rule 29 (const -> FLOAT .)
    CMP             reduce using rule 29 (const -> FLOAT .)
    NEWLINE         reduce using rule 29 (const -> FLOAT .)
    SEMICOLON       reduce using rule 29 (const -> FLOAT .)
    DO              reduce using rule 29 (const -> FLOAT .)
    WITH            reduce using rule 29 (const -> FLOAT .)


state 43

    (30) const -> BOOL .

    TO              reduce using rule 30 (const -> BOOL .)
    error           reduce using rule 30 (const -> BOOL .)
    PLUS            reduce using rule 30 (const -> BOOL .)
    MINUS           reduce using rule 30 (const -> BOOL .)
    AND             reduce using rule 30 (const -> BOOL .)
    OR              reduce using rule 30 (const -> BOOL .)
    CMP             reduce using rule 30 (const -> BOOL .)
    NEWLINE         reduce using rule 30 (const -> BOOL .)
    SEMICOLON       reduce using rule 30 (const -> BOOL .)
    DO              reduce using rule 30 (const -> BOOL .)
    WITH            reduce using rule 30 (const -> BOOL .)


state 44

    (31) const -> CELLTYPE .

    TO              reduce using rule 31 (const -> CELLTYPE .)
    error           reduce using rule 31 (const -> CELLTYPE .)
    PLUS            reduce using rule 31 (const -> CELLTYPE .)
    MINUS           reduce using rule 31 (const -> CELLTYPE .)
    AND             reduce using rule 31 (const -> CELLTYPE .)
    OR              reduce using rule 31 (const -> CELLTYPE .)
    CMP             reduce using rule 31 (const -> CELLTYPE .)
    NEWLINE         reduce using rule 31 (const -> CELLTYPE .)
    SEMICOLON       reduce using rule 31 (const -> CELLTYPE .)
    DO              reduce using rule 31 (const -> CELLTYPE .)
    WITH            reduce using rule 31 (const -> CELLTYPE .)


state 45

    (34) operation -> MINUS . expression
    (23) expression -> . variable
    (24) expression -> . const
    (25) expression -> . operation
    (26) expression -> . logic_expr
    (27) expression -> . function_call
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (28) const -> . INT
    (29) const -> . FLOAT
    (30) const -> . BOOL
    (31) const -> . CELLTYPE
    (32) operation -> . expression PLUS expression
    (33) operation -> . expression MINUS expression
    (34) operation -> . MINUS expression
    (42) logic_expr -> . expression AND expression
    (43) logic_expr -> . expression OR expression
    (44) logic_expr -> . expression CMP expression
    (39) function_call -> . DO NAME

    NAME            shift and go to state 12
    INT             shift and go to state 41
    FLOAT           shift and go to state 42
    BOOL            shift and go to state 43
    CELLTYPE        shift and go to state 44
    MINUS           shift and go to state 45
    DO              shift and go to state 15

    expression                     shift and go to state 65
    variable                       shift and go to state 37
    const                          shift and go to state 38
    operation                      shift and go to state 39
    logic_expr                     shift and go to state 40
    function_call                  shift and go to state 36

state 46

    (39) function_call -> DO NAME .

    NEWLINE         reduce using rule 39 (function_call -> DO NAME .)
    SEMICOLON       reduce using rule 39 (function_call -> DO NAME .)
    TO              reduce using rule 39 (function_call -> DO NAME .)
    error           reduce using rule 39 (function_call -> DO NAME .)
    PLUS            reduce using rule 39 (function_call -> DO NAME .)
    MINUS           reduce using rule 39 (function_call -> DO NAME .)
    AND             reduce using rule 39 (function_call -> DO NAME .)
    OR              reduce using rule 39 (function_call -> DO NAME .)
    CMP             reduce using rule 39 (function_call -> DO NAME .)
    DO              reduce using rule 39 (function_call -> DO NAME .)
    WITH            reduce using rule 39 (function_call -> DO NAME .)


state 47

    (45) function -> FUNCTION NAME . NEWLINE statements END
    (60) function -> FUNCTION NAME . error statements END

    NEWLINE         shift and go to state 66
    error           shift and go to state 67


state 48

    (40) if -> IF logic_expr . function_call
    (41) if -> IF logic_expr . DO FUNCTION NEWLINE statements END
    (55) if -> IF logic_expr . DO FUNCTION error statements END
    (56) if -> IF logic_expr . DO error NEWLINE statements END
    (59) if -> IF logic_expr . error FUNCTION NEWLINE statements END
    (26) expression -> logic_expr .
    (39) function_call -> . DO NAME

    DO              shift and go to state 69
    error           shift and go to state 70
    AND             reduce using rule 26 (expression -> logic_expr .)
    OR              reduce using rule 26 (expression -> logic_expr .)
    CMP             reduce using rule 26 (expression -> logic_expr .)
    PLUS            reduce using rule 26 (expression -> logic_expr .)
    MINUS           reduce using rule 26 (expression -> logic_expr .)

    function_call                  shift and go to state 68

state 49

    (57) if -> IF error . DO FUNCTION NEWLINE statements END
    (58) if -> IF error . function_call
    (39) function_call -> . DO NAME

    DO              shift and go to state 71

    function_call                  shift and go to state 72

state 50

    (42) logic_expr -> expression . AND expression
    (43) logic_expr -> expression . OR expression
    (44) logic_expr -> expression . CMP expression
    (32) operation -> expression . PLUS expression
    (33) operation -> expression . MINUS expression

    AND             shift and go to state 62
    OR              shift and go to state 63
    CMP             shift and go to state 64
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61


state 51

    (2) command -> CMD DIRECT .

    NEWLINE         reduce using rule 2 (command -> CMD DIRECT .)
    SEMICOLON       reduce using rule 2 (command -> CMD DIRECT .)


state 52

    (15) eoe -> SEMICOLON NEWLINE .

    NAME            reduce using rule 15 (eoe -> SEMICOLON NEWLINE .)
    FROM            reduce using rule 15 (eoe -> SEMICOLON NEWLINE .)
    IF              reduce using rule 15 (eoe -> SEMICOLON NEWLINE .)
    FUNCTION        reduce using rule 15 (eoe -> SEMICOLON NEWLINE .)
    error           reduce using rule 15 (eoe -> SEMICOLON NEWLINE .)
    DO              reduce using rule 15 (eoe -> SEMICOLON NEWLINE .)
    CMD             reduce using rule 15 (eoe -> SEMICOLON NEWLINE .)
    NEWLINE         reduce using rule 15 (eoe -> SEMICOLON NEWLINE .)
    SEMICOLON       reduce using rule 15 (eoe -> SEMICOLON NEWLINE .)
    $end            reduce using rule 15 (eoe -> SEMICOLON NEWLINE .)
    END             reduce using rule 15 (eoe -> SEMICOLON NEWLINE .)


state 53

    (17) assignment -> variable ASSIGNMENT expression .
    (32) operation -> expression . PLUS expression
    (33) operation -> expression . MINUS expression
    (42) logic_expr -> expression . AND expression
    (43) logic_expr -> expression . OR expression
    (44) logic_expr -> expression . CMP expression

    NEWLINE         reduce using rule 17 (assignment -> variable ASSIGNMENT expression .)
    SEMICOLON       reduce using rule 17 (assignment -> variable ASSIGNMENT expression .)
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    CMP             shift and go to state 64


state 54

    (46) assignment -> variable ASSIGNMENT error .

    NEWLINE         reduce using rule 46 (assignment -> variable ASSIGNMENT error .)
    SEMICOLON       reduce using rule 46 (assignment -> variable ASSIGNMENT error .)


state 55

    (21) index -> index COMMA . INT

    INT             shift and go to state 73


state 56

    (19) variable -> NAME LBRACKET index . RBRACKET
    (21) index -> index . COMMA INT

    RBRACKET        shift and go to state 74
    COMMA           shift and go to state 55


state 57

    (61) function -> error NAME NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 75
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 58

    (35) from -> FROM expression TO . expression DO FUNCTION NEWLINE statements END
    (36) from -> FROM expression TO . expression function_call
    (37) from -> FROM expression TO . expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> FROM expression TO . expression WITH STEP expression function_call
    (47) from -> FROM expression TO . expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> FROM expression TO . expression DO FUNCTION error statements END
    (51) from -> FROM expression TO . expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> FROM expression TO . expression DO error NEWLINE statements END
    (53) from -> FROM expression TO . expression error FUNCTION NEWLINE statements END
    (54) from -> FROM expression TO . expression WITH STEP expression error FUNCTION NEWLINE statements END
    (23) expression -> . variable
    (24) expression -> . const
    (25) expression -> . operation
    (26) expression -> . logic_expr
    (27) expression -> . function_call
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (28) const -> . INT
    (29) const -> . FLOAT
    (30) const -> . BOOL
    (31) const -> . CELLTYPE
    (32) operation -> . expression PLUS expression
    (33) operation -> . expression MINUS expression
    (34) operation -> . MINUS expression
    (42) logic_expr -> . expression AND expression
    (43) logic_expr -> . expression OR expression
    (44) logic_expr -> . expression CMP expression
    (39) function_call -> . DO NAME

    NAME            shift and go to state 12
    INT             shift and go to state 41
    FLOAT           shift and go to state 42
    BOOL            shift and go to state 43
    CELLTYPE        shift and go to state 44
    MINUS           shift and go to state 45
    DO              shift and go to state 15

    expression                     shift and go to state 76
    function_call                  shift and go to state 36
    variable                       shift and go to state 37
    const                          shift and go to state 38
    operation                      shift and go to state 39
    logic_expr                     shift and go to state 40

state 59

    (49) from -> FROM expression error . expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> FROM expression error . expression DO FUNCTION NEWLINE statements END
    (23) expression -> . variable
    (24) expression -> . const
    (25) expression -> . operation
    (26) expression -> . logic_expr
    (27) expression -> . function_call
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (28) const -> . INT
    (29) const -> . FLOAT
    (30) const -> . BOOL
    (31) const -> . CELLTYPE
    (32) operation -> . expression PLUS expression
    (33) operation -> . expression MINUS expression
    (34) operation -> . MINUS expression
    (42) logic_expr -> . expression AND expression
    (43) logic_expr -> . expression OR expression
    (44) logic_expr -> . expression CMP expression
    (39) function_call -> . DO NAME

    NAME            shift and go to state 12
    INT             shift and go to state 41
    FLOAT           shift and go to state 42
    BOOL            shift and go to state 43
    CELLTYPE        shift and go to state 44
    MINUS           shift and go to state 45
    DO              shift and go to state 15

    expression                     shift and go to state 77
    variable                       shift and go to state 37
    const                          shift and go to state 38
    operation                      shift and go to state 39
    logic_expr                     shift and go to state 40
    function_call                  shift and go to state 36

state 60

    (32) operation -> expression PLUS . expression
    (23) expression -> . variable
    (24) expression -> . const
    (25) expression -> . operation
    (26) expression -> . logic_expr
    (27) expression -> . function_call
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (28) const -> . INT
    (29) const -> . FLOAT
    (30) const -> . BOOL
    (31) const -> . CELLTYPE
    (32) operation -> . expression PLUS expression
    (33) operation -> . expression MINUS expression
    (34) operation -> . MINUS expression
    (42) logic_expr -> . expression AND expression
    (43) logic_expr -> . expression OR expression
    (44) logic_expr -> . expression CMP expression
    (39) function_call -> . DO NAME

    NAME            shift and go to state 12
    INT             shift and go to state 41
    FLOAT           shift and go to state 42
    BOOL            shift and go to state 43
    CELLTYPE        shift and go to state 44
    MINUS           shift and go to state 45
    DO              shift and go to state 15

    expression                     shift and go to state 78
    variable                       shift and go to state 37
    const                          shift and go to state 38
    operation                      shift and go to state 39
    logic_expr                     shift and go to state 40
    function_call                  shift and go to state 36

state 61

    (33) operation -> expression MINUS . expression
    (23) expression -> . variable
    (24) expression -> . const
    (25) expression -> . operation
    (26) expression -> . logic_expr
    (27) expression -> . function_call
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (28) const -> . INT
    (29) const -> . FLOAT
    (30) const -> . BOOL
    (31) const -> . CELLTYPE
    (32) operation -> . expression PLUS expression
    (33) operation -> . expression MINUS expression
    (34) operation -> . MINUS expression
    (42) logic_expr -> . expression AND expression
    (43) logic_expr -> . expression OR expression
    (44) logic_expr -> . expression CMP expression
    (39) function_call -> . DO NAME

    NAME            shift and go to state 12
    INT             shift and go to state 41
    FLOAT           shift and go to state 42
    BOOL            shift and go to state 43
    CELLTYPE        shift and go to state 44
    MINUS           shift and go to state 45
    DO              shift and go to state 15

    expression                     shift and go to state 79
    variable                       shift and go to state 37
    const                          shift and go to state 38
    operation                      shift and go to state 39
    logic_expr                     shift and go to state 40
    function_call                  shift and go to state 36

state 62

    (42) logic_expr -> expression AND . expression
    (23) expression -> . variable
    (24) expression -> . const
    (25) expression -> . operation
    (26) expression -> . logic_expr
    (27) expression -> . function_call
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (28) const -> . INT
    (29) const -> . FLOAT
    (30) const -> . BOOL
    (31) const -> . CELLTYPE
    (32) operation -> . expression PLUS expression
    (33) operation -> . expression MINUS expression
    (34) operation -> . MINUS expression
    (42) logic_expr -> . expression AND expression
    (43) logic_expr -> . expression OR expression
    (44) logic_expr -> . expression CMP expression
    (39) function_call -> . DO NAME

    NAME            shift and go to state 12
    INT             shift and go to state 41
    FLOAT           shift and go to state 42
    BOOL            shift and go to state 43
    CELLTYPE        shift and go to state 44
    MINUS           shift and go to state 45
    DO              shift and go to state 15

    expression                     shift and go to state 80
    variable                       shift and go to state 37
    const                          shift and go to state 38
    operation                      shift and go to state 39
    logic_expr                     shift and go to state 40
    function_call                  shift and go to state 36

state 63

    (43) logic_expr -> expression OR . expression
    (23) expression -> . variable
    (24) expression -> . const
    (25) expression -> . operation
    (26) expression -> . logic_expr
    (27) expression -> . function_call
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (28) const -> . INT
    (29) const -> . FLOAT
    (30) const -> . BOOL
    (31) const -> . CELLTYPE
    (32) operation -> . expression PLUS expression
    (33) operation -> . expression MINUS expression
    (34) operation -> . MINUS expression
    (42) logic_expr -> . expression AND expression
    (43) logic_expr -> . expression OR expression
    (44) logic_expr -> . expression CMP expression
    (39) function_call -> . DO NAME

    NAME            shift and go to state 12
    INT             shift and go to state 41
    FLOAT           shift and go to state 42
    BOOL            shift and go to state 43
    CELLTYPE        shift and go to state 44
    MINUS           shift and go to state 45
    DO              shift and go to state 15

    expression                     shift and go to state 81
    variable                       shift and go to state 37
    const                          shift and go to state 38
    operation                      shift and go to state 39
    logic_expr                     shift and go to state 40
    function_call                  shift and go to state 36

state 64

    (44) logic_expr -> expression CMP . expression
    (23) expression -> . variable
    (24) expression -> . const
    (25) expression -> . operation
    (26) expression -> . logic_expr
    (27) expression -> . function_call
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (28) const -> . INT
    (29) const -> . FLOAT
    (30) const -> . BOOL
    (31) const -> . CELLTYPE
    (32) operation -> . expression PLUS expression
    (33) operation -> . expression MINUS expression
    (34) operation -> . MINUS expression
    (42) logic_expr -> . expression AND expression
    (43) logic_expr -> . expression OR expression
    (44) logic_expr -> . expression CMP expression
    (39) function_call -> . DO NAME

    NAME            shift and go to state 12
    INT             shift and go to state 41
    FLOAT           shift and go to state 42
    BOOL            shift and go to state 43
    CELLTYPE        shift and go to state 44
    MINUS           shift and go to state 45
    DO              shift and go to state 15

    expression                     shift and go to state 82
    variable                       shift and go to state 37
    const                          shift and go to state 38
    operation                      shift and go to state 39
    logic_expr                     shift and go to state 40
    function_call                  shift and go to state 36

state 65

    (34) operation -> MINUS expression .
    (32) operation -> expression . PLUS expression
    (33) operation -> expression . MINUS expression
    (42) logic_expr -> expression . AND expression
    (43) logic_expr -> expression . OR expression
    (44) logic_expr -> expression . CMP expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for CMP resolved as shift
    TO              reduce using rule 34 (operation -> MINUS expression .)
    error           reduce using rule 34 (operation -> MINUS expression .)
    NEWLINE         reduce using rule 34 (operation -> MINUS expression .)
    SEMICOLON       reduce using rule 34 (operation -> MINUS expression .)
    DO              reduce using rule 34 (operation -> MINUS expression .)
    WITH            reduce using rule 34 (operation -> MINUS expression .)
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    CMP             shift and go to state 64

  ! PLUS            [ reduce using rule 34 (operation -> MINUS expression .) ]
  ! MINUS           [ reduce using rule 34 (operation -> MINUS expression .) ]
  ! AND             [ reduce using rule 34 (operation -> MINUS expression .) ]
  ! OR              [ reduce using rule 34 (operation -> MINUS expression .) ]
  ! CMP             [ reduce using rule 34 (operation -> MINUS expression .) ]


state 66

    (45) function -> FUNCTION NAME NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 83
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 67

    (60) function -> FUNCTION NAME error . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 84
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 68

    (40) if -> IF logic_expr function_call .

    NEWLINE         reduce using rule 40 (if -> IF logic_expr function_call .)
    SEMICOLON       reduce using rule 40 (if -> IF logic_expr function_call .)


state 69

    (41) if -> IF logic_expr DO . FUNCTION NEWLINE statements END
    (55) if -> IF logic_expr DO . FUNCTION error statements END
    (56) if -> IF logic_expr DO . error NEWLINE statements END
    (39) function_call -> DO . NAME

    FUNCTION        shift and go to state 85
    error           shift and go to state 86
    NAME            shift and go to state 46


state 70

    (59) if -> IF logic_expr error . FUNCTION NEWLINE statements END

    FUNCTION        shift and go to state 87


state 71

    (57) if -> IF error DO . FUNCTION NEWLINE statements END
    (39) function_call -> DO . NAME

    FUNCTION        shift and go to state 88
    NAME            shift and go to state 46


state 72

    (58) if -> IF error function_call .

    NEWLINE         reduce using rule 58 (if -> IF error function_call .)
    SEMICOLON       reduce using rule 58 (if -> IF error function_call .)


state 73

    (21) index -> index COMMA INT .

    COMMA           reduce using rule 21 (index -> index COMMA INT .)
    ASSIGNMENT      reduce using rule 21 (index -> index COMMA INT .)
    NEWLINE         reduce using rule 21 (index -> index COMMA INT .)
    SEMICOLON       reduce using rule 21 (index -> index COMMA INT .)
    TO              reduce using rule 21 (index -> index COMMA INT .)
    error           reduce using rule 21 (index -> index COMMA INT .)
    PLUS            reduce using rule 21 (index -> index COMMA INT .)
    MINUS           reduce using rule 21 (index -> index COMMA INT .)
    AND             reduce using rule 21 (index -> index COMMA INT .)
    OR              reduce using rule 21 (index -> index COMMA INT .)
    CMP             reduce using rule 21 (index -> index COMMA INT .)
    DO              reduce using rule 21 (index -> index COMMA INT .)
    WITH            reduce using rule 21 (index -> index COMMA INT .)
    RBRACKET        reduce using rule 21 (index -> index COMMA INT .)


state 74

    (19) variable -> NAME LBRACKET index RBRACKET .

    ASSIGNMENT      reduce using rule 19 (variable -> NAME LBRACKET index RBRACKET .)
    NEWLINE         reduce using rule 19 (variable -> NAME LBRACKET index RBRACKET .)
    SEMICOLON       reduce using rule 19 (variable -> NAME LBRACKET index RBRACKET .)
    TO              reduce using rule 19 (variable -> NAME LBRACKET index RBRACKET .)
    error           reduce using rule 19 (variable -> NAME LBRACKET index RBRACKET .)
    PLUS            reduce using rule 19 (variable -> NAME LBRACKET index RBRACKET .)
    MINUS           reduce using rule 19 (variable -> NAME LBRACKET index RBRACKET .)
    AND             reduce using rule 19 (variable -> NAME LBRACKET index RBRACKET .)
    OR              reduce using rule 19 (variable -> NAME LBRACKET index RBRACKET .)
    CMP             reduce using rule 19 (variable -> NAME LBRACKET index RBRACKET .)
    DO              reduce using rule 19 (variable -> NAME LBRACKET index RBRACKET .)
    WITH            reduce using rule 19 (variable -> NAME LBRACKET index RBRACKET .)


state 75

    (61) function -> error NAME NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 89
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 76

    (35) from -> FROM expression TO expression . DO FUNCTION NEWLINE statements END
    (36) from -> FROM expression TO expression . function_call
    (37) from -> FROM expression TO expression . WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> FROM expression TO expression . WITH STEP expression function_call
    (47) from -> FROM expression TO expression . WITH STEP expression DO FUNCTION error statements END
    (48) from -> FROM expression TO expression . DO FUNCTION error statements END
    (51) from -> FROM expression TO expression . WITH STEP expression DO error NEWLINE statements END
    (52) from -> FROM expression TO expression . DO error NEWLINE statements END
    (53) from -> FROM expression TO expression . error FUNCTION NEWLINE statements END
    (54) from -> FROM expression TO expression . WITH STEP expression error FUNCTION NEWLINE statements END
    (32) operation -> expression . PLUS expression
    (33) operation -> expression . MINUS expression
    (42) logic_expr -> expression . AND expression
    (43) logic_expr -> expression . OR expression
    (44) logic_expr -> expression . CMP expression
    (39) function_call -> . DO NAME

    DO              shift and go to state 90
    WITH            shift and go to state 92
    error           shift and go to state 93
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    CMP             shift and go to state 64

    function_call                  shift and go to state 91

state 77

    (49) from -> FROM expression error expression . WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> FROM expression error expression . DO FUNCTION NEWLINE statements END
    (32) operation -> expression . PLUS expression
    (33) operation -> expression . MINUS expression
    (42) logic_expr -> expression . AND expression
    (43) logic_expr -> expression . OR expression
    (44) logic_expr -> expression . CMP expression

    WITH            shift and go to state 94
    DO              shift and go to state 95
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    CMP             shift and go to state 64


state 78

    (32) operation -> expression PLUS expression .
    (32) operation -> expression . PLUS expression
    (33) operation -> expression . MINUS expression
    (42) logic_expr -> expression . AND expression
    (43) logic_expr -> expression . OR expression
    (44) logic_expr -> expression . CMP expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for CMP resolved as shift
    TO              reduce using rule 32 (operation -> expression PLUS expression .)
    error           reduce using rule 32 (operation -> expression PLUS expression .)
    NEWLINE         reduce using rule 32 (operation -> expression PLUS expression .)
    SEMICOLON       reduce using rule 32 (operation -> expression PLUS expression .)
    DO              reduce using rule 32 (operation -> expression PLUS expression .)
    WITH            reduce using rule 32 (operation -> expression PLUS expression .)
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    CMP             shift and go to state 64

  ! PLUS            [ reduce using rule 32 (operation -> expression PLUS expression .) ]
  ! MINUS           [ reduce using rule 32 (operation -> expression PLUS expression .) ]
  ! AND             [ reduce using rule 32 (operation -> expression PLUS expression .) ]
  ! OR              [ reduce using rule 32 (operation -> expression PLUS expression .) ]
  ! CMP             [ reduce using rule 32 (operation -> expression PLUS expression .) ]


state 79

    (33) operation -> expression MINUS expression .
    (32) operation -> expression . PLUS expression
    (33) operation -> expression . MINUS expression
    (42) logic_expr -> expression . AND expression
    (43) logic_expr -> expression . OR expression
    (44) logic_expr -> expression . CMP expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for CMP resolved as shift
    TO              reduce using rule 33 (operation -> expression MINUS expression .)
    error           reduce using rule 33 (operation -> expression MINUS expression .)
    NEWLINE         reduce using rule 33 (operation -> expression MINUS expression .)
    SEMICOLON       reduce using rule 33 (operation -> expression MINUS expression .)
    DO              reduce using rule 33 (operation -> expression MINUS expression .)
    WITH            reduce using rule 33 (operation -> expression MINUS expression .)
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    CMP             shift and go to state 64

  ! PLUS            [ reduce using rule 33 (operation -> expression MINUS expression .) ]
  ! MINUS           [ reduce using rule 33 (operation -> expression MINUS expression .) ]
  ! AND             [ reduce using rule 33 (operation -> expression MINUS expression .) ]
  ! OR              [ reduce using rule 33 (operation -> expression MINUS expression .) ]
  ! CMP             [ reduce using rule 33 (operation -> expression MINUS expression .) ]


state 80

    (42) logic_expr -> expression AND expression .
    (32) operation -> expression . PLUS expression
    (33) operation -> expression . MINUS expression
    (42) logic_expr -> expression . AND expression
    (43) logic_expr -> expression . OR expression
    (44) logic_expr -> expression . CMP expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for CMP resolved as shift
    TO              reduce using rule 42 (logic_expr -> expression AND expression .)
    error           reduce using rule 42 (logic_expr -> expression AND expression .)
    DO              reduce using rule 42 (logic_expr -> expression AND expression .)
    NEWLINE         reduce using rule 42 (logic_expr -> expression AND expression .)
    SEMICOLON       reduce using rule 42 (logic_expr -> expression AND expression .)
    WITH            reduce using rule 42 (logic_expr -> expression AND expression .)
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    CMP             shift and go to state 64

  ! PLUS            [ reduce using rule 42 (logic_expr -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 42 (logic_expr -> expression AND expression .) ]
  ! AND             [ reduce using rule 42 (logic_expr -> expression AND expression .) ]
  ! OR              [ reduce using rule 42 (logic_expr -> expression AND expression .) ]
  ! CMP             [ reduce using rule 42 (logic_expr -> expression AND expression .) ]


state 81

    (43) logic_expr -> expression OR expression .
    (32) operation -> expression . PLUS expression
    (33) operation -> expression . MINUS expression
    (42) logic_expr -> expression . AND expression
    (43) logic_expr -> expression . OR expression
    (44) logic_expr -> expression . CMP expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for CMP resolved as shift
    TO              reduce using rule 43 (logic_expr -> expression OR expression .)
    error           reduce using rule 43 (logic_expr -> expression OR expression .)
    DO              reduce using rule 43 (logic_expr -> expression OR expression .)
    NEWLINE         reduce using rule 43 (logic_expr -> expression OR expression .)
    SEMICOLON       reduce using rule 43 (logic_expr -> expression OR expression .)
    WITH            reduce using rule 43 (logic_expr -> expression OR expression .)
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    CMP             shift and go to state 64

  ! PLUS            [ reduce using rule 43 (logic_expr -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 43 (logic_expr -> expression OR expression .) ]
  ! AND             [ reduce using rule 43 (logic_expr -> expression OR expression .) ]
  ! OR              [ reduce using rule 43 (logic_expr -> expression OR expression .) ]
  ! CMP             [ reduce using rule 43 (logic_expr -> expression OR expression .) ]


state 82

    (44) logic_expr -> expression CMP expression .
    (32) operation -> expression . PLUS expression
    (33) operation -> expression . MINUS expression
    (42) logic_expr -> expression . AND expression
    (43) logic_expr -> expression . OR expression
    (44) logic_expr -> expression . CMP expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for CMP resolved as shift
    TO              reduce using rule 44 (logic_expr -> expression CMP expression .)
    error           reduce using rule 44 (logic_expr -> expression CMP expression .)
    DO              reduce using rule 44 (logic_expr -> expression CMP expression .)
    NEWLINE         reduce using rule 44 (logic_expr -> expression CMP expression .)
    SEMICOLON       reduce using rule 44 (logic_expr -> expression CMP expression .)
    WITH            reduce using rule 44 (logic_expr -> expression CMP expression .)
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    CMP             shift and go to state 64

  ! PLUS            [ reduce using rule 44 (logic_expr -> expression CMP expression .) ]
  ! MINUS           [ reduce using rule 44 (logic_expr -> expression CMP expression .) ]
  ! AND             [ reduce using rule 44 (logic_expr -> expression CMP expression .) ]
  ! OR              [ reduce using rule 44 (logic_expr -> expression CMP expression .) ]
  ! CMP             [ reduce using rule 44 (logic_expr -> expression CMP expression .) ]


state 83

    (45) function -> FUNCTION NAME NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 96
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 84

    (60) function -> FUNCTION NAME error statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 97
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 85

    (41) if -> IF logic_expr DO FUNCTION . NEWLINE statements END
    (55) if -> IF logic_expr DO FUNCTION . error statements END

    NEWLINE         shift and go to state 98
    error           shift and go to state 99


state 86

    (56) if -> IF logic_expr DO error . NEWLINE statements END

    NEWLINE         shift and go to state 100


state 87

    (59) if -> IF logic_expr error FUNCTION . NEWLINE statements END

    NEWLINE         shift and go to state 101


state 88

    (57) if -> IF error DO FUNCTION . NEWLINE statements END

    NEWLINE         shift and go to state 102


state 89

    (61) function -> error NAME NEWLINE statements END .

    NEWLINE         reduce using rule 61 (function -> error NAME NEWLINE statements END .)
    SEMICOLON       reduce using rule 61 (function -> error NAME NEWLINE statements END .)


state 90

    (35) from -> FROM expression TO expression DO . FUNCTION NEWLINE statements END
    (48) from -> FROM expression TO expression DO . FUNCTION error statements END
    (52) from -> FROM expression TO expression DO . error NEWLINE statements END
    (39) function_call -> DO . NAME

    FUNCTION        shift and go to state 103
    error           shift and go to state 104
    NAME            shift and go to state 46


state 91

    (36) from -> FROM expression TO expression function_call .

    NEWLINE         reduce using rule 36 (from -> FROM expression TO expression function_call .)
    SEMICOLON       reduce using rule 36 (from -> FROM expression TO expression function_call .)


state 92

    (37) from -> FROM expression TO expression WITH . STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> FROM expression TO expression WITH . STEP expression function_call
    (47) from -> FROM expression TO expression WITH . STEP expression DO FUNCTION error statements END
    (51) from -> FROM expression TO expression WITH . STEP expression DO error NEWLINE statements END
    (54) from -> FROM expression TO expression WITH . STEP expression error FUNCTION NEWLINE statements END

    STEP            shift and go to state 105


state 93

    (53) from -> FROM expression TO expression error . FUNCTION NEWLINE statements END

    FUNCTION        shift and go to state 106


state 94

    (49) from -> FROM expression error expression WITH . STEP expression DO FUNCTION NEWLINE statements END

    STEP            shift and go to state 107


state 95

    (50) from -> FROM expression error expression DO . FUNCTION NEWLINE statements END

    FUNCTION        shift and go to state 108


state 96

    (45) function -> FUNCTION NAME NEWLINE statements END .

    NEWLINE         reduce using rule 45 (function -> FUNCTION NAME NEWLINE statements END .)
    SEMICOLON       reduce using rule 45 (function -> FUNCTION NAME NEWLINE statements END .)


state 97

    (60) function -> FUNCTION NAME error statements END .

    NEWLINE         reduce using rule 60 (function -> FUNCTION NAME error statements END .)
    SEMICOLON       reduce using rule 60 (function -> FUNCTION NAME error statements END .)


state 98

    (41) if -> IF logic_expr DO FUNCTION NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 109
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 99

    (55) if -> IF logic_expr DO FUNCTION error . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 110
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 100

    (56) if -> IF logic_expr DO error NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 111
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 101

    (59) if -> IF logic_expr error FUNCTION NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 112
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 102

    (57) if -> IF error DO FUNCTION NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 113
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 103

    (35) from -> FROM expression TO expression DO FUNCTION . NEWLINE statements END
    (48) from -> FROM expression TO expression DO FUNCTION . error statements END

    NEWLINE         shift and go to state 114
    error           shift and go to state 115


state 104

    (52) from -> FROM expression TO expression DO error . NEWLINE statements END

    NEWLINE         shift and go to state 116


state 105

    (37) from -> FROM expression TO expression WITH STEP . expression DO FUNCTION NEWLINE statements END
    (38) from -> FROM expression TO expression WITH STEP . expression function_call
    (47) from -> FROM expression TO expression WITH STEP . expression DO FUNCTION error statements END
    (51) from -> FROM expression TO expression WITH STEP . expression DO error NEWLINE statements END
    (54) from -> FROM expression TO expression WITH STEP . expression error FUNCTION NEWLINE statements END
    (23) expression -> . variable
    (24) expression -> . const
    (25) expression -> . operation
    (26) expression -> . logic_expr
    (27) expression -> . function_call
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (28) const -> . INT
    (29) const -> . FLOAT
    (30) const -> . BOOL
    (31) const -> . CELLTYPE
    (32) operation -> . expression PLUS expression
    (33) operation -> . expression MINUS expression
    (34) operation -> . MINUS expression
    (42) logic_expr -> . expression AND expression
    (43) logic_expr -> . expression OR expression
    (44) logic_expr -> . expression CMP expression
    (39) function_call -> . DO NAME

    NAME            shift and go to state 12
    INT             shift and go to state 41
    FLOAT           shift and go to state 42
    BOOL            shift and go to state 43
    CELLTYPE        shift and go to state 44
    MINUS           shift and go to state 45
    DO              shift and go to state 15

    expression                     shift and go to state 117
    function_call                  shift and go to state 36
    variable                       shift and go to state 37
    const                          shift and go to state 38
    operation                      shift and go to state 39
    logic_expr                     shift and go to state 40

state 106

    (53) from -> FROM expression TO expression error FUNCTION . NEWLINE statements END

    NEWLINE         shift and go to state 118


state 107

    (49) from -> FROM expression error expression WITH STEP . expression DO FUNCTION NEWLINE statements END
    (23) expression -> . variable
    (24) expression -> . const
    (25) expression -> . operation
    (26) expression -> . logic_expr
    (27) expression -> . function_call
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (28) const -> . INT
    (29) const -> . FLOAT
    (30) const -> . BOOL
    (31) const -> . CELLTYPE
    (32) operation -> . expression PLUS expression
    (33) operation -> . expression MINUS expression
    (34) operation -> . MINUS expression
    (42) logic_expr -> . expression AND expression
    (43) logic_expr -> . expression OR expression
    (44) logic_expr -> . expression CMP expression
    (39) function_call -> . DO NAME

    NAME            shift and go to state 12
    INT             shift and go to state 41
    FLOAT           shift and go to state 42
    BOOL            shift and go to state 43
    CELLTYPE        shift and go to state 44
    MINUS           shift and go to state 45
    DO              shift and go to state 15

    expression                     shift and go to state 119
    variable                       shift and go to state 37
    const                          shift and go to state 38
    operation                      shift and go to state 39
    logic_expr                     shift and go to state 40
    function_call                  shift and go to state 36

state 108

    (50) from -> FROM expression error expression DO FUNCTION . NEWLINE statements END

    NEWLINE         shift and go to state 120


state 109

    (41) if -> IF logic_expr DO FUNCTION NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 121
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 110

    (55) if -> IF logic_expr DO FUNCTION error statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 122
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 111

    (56) if -> IF logic_expr DO error NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 123
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 112

    (59) if -> IF logic_expr error FUNCTION NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 124
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 113

    (57) if -> IF error DO FUNCTION NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 125
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 114

    (35) from -> FROM expression TO expression DO FUNCTION NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 126
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 115

    (48) from -> FROM expression TO expression DO FUNCTION error . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 127
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 116

    (52) from -> FROM expression TO expression DO error NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 128
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 117

    (37) from -> FROM expression TO expression WITH STEP expression . DO FUNCTION NEWLINE statements END
    (38) from -> FROM expression TO expression WITH STEP expression . function_call
    (47) from -> FROM expression TO expression WITH STEP expression . DO FUNCTION error statements END
    (51) from -> FROM expression TO expression WITH STEP expression . DO error NEWLINE statements END
    (54) from -> FROM expression TO expression WITH STEP expression . error FUNCTION NEWLINE statements END
    (32) operation -> expression . PLUS expression
    (33) operation -> expression . MINUS expression
    (42) logic_expr -> expression . AND expression
    (43) logic_expr -> expression . OR expression
    (44) logic_expr -> expression . CMP expression
    (39) function_call -> . DO NAME

    DO              shift and go to state 129
    error           shift and go to state 131
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    CMP             shift and go to state 64

    function_call                  shift and go to state 130

state 118

    (53) from -> FROM expression TO expression error FUNCTION NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 132
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 119

    (49) from -> FROM expression error expression WITH STEP expression . DO FUNCTION NEWLINE statements END
    (32) operation -> expression . PLUS expression
    (33) operation -> expression . MINUS expression
    (42) logic_expr -> expression . AND expression
    (43) logic_expr -> expression . OR expression
    (44) logic_expr -> expression . CMP expression

    DO              shift and go to state 133
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    AND             shift and go to state 62
    OR              shift and go to state 63
    CMP             shift and go to state 64


state 120

    (50) from -> FROM expression error expression DO FUNCTION NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 134
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 121

    (41) if -> IF logic_expr DO FUNCTION NEWLINE statements END .

    NEWLINE         reduce using rule 41 (if -> IF logic_expr DO FUNCTION NEWLINE statements END .)
    SEMICOLON       reduce using rule 41 (if -> IF logic_expr DO FUNCTION NEWLINE statements END .)


state 122

    (55) if -> IF logic_expr DO FUNCTION error statements END .

    NEWLINE         reduce using rule 55 (if -> IF logic_expr DO FUNCTION error statements END .)
    SEMICOLON       reduce using rule 55 (if -> IF logic_expr DO FUNCTION error statements END .)


state 123

    (56) if -> IF logic_expr DO error NEWLINE statements END .

    NEWLINE         reduce using rule 56 (if -> IF logic_expr DO error NEWLINE statements END .)
    SEMICOLON       reduce using rule 56 (if -> IF logic_expr DO error NEWLINE statements END .)


state 124

    (59) if -> IF logic_expr error FUNCTION NEWLINE statements END .

    NEWLINE         reduce using rule 59 (if -> IF logic_expr error FUNCTION NEWLINE statements END .)
    SEMICOLON       reduce using rule 59 (if -> IF logic_expr error FUNCTION NEWLINE statements END .)


state 125

    (57) if -> IF error DO FUNCTION NEWLINE statements END .

    NEWLINE         reduce using rule 57 (if -> IF error DO FUNCTION NEWLINE statements END .)
    SEMICOLON       reduce using rule 57 (if -> IF error DO FUNCTION NEWLINE statements END .)


state 126

    (35) from -> FROM expression TO expression DO FUNCTION NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 135
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 127

    (48) from -> FROM expression TO expression DO FUNCTION error statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 136
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 128

    (52) from -> FROM expression TO expression DO error NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 137
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 129

    (37) from -> FROM expression TO expression WITH STEP expression DO . FUNCTION NEWLINE statements END
    (47) from -> FROM expression TO expression WITH STEP expression DO . FUNCTION error statements END
    (51) from -> FROM expression TO expression WITH STEP expression DO . error NEWLINE statements END
    (39) function_call -> DO . NAME

    FUNCTION        shift and go to state 138
    error           shift and go to state 139
    NAME            shift and go to state 46


state 130

    (38) from -> FROM expression TO expression WITH STEP expression function_call .

    NEWLINE         reduce using rule 38 (from -> FROM expression TO expression WITH STEP expression function_call .)
    SEMICOLON       reduce using rule 38 (from -> FROM expression TO expression WITH STEP expression function_call .)


state 131

    (54) from -> FROM expression TO expression WITH STEP expression error . FUNCTION NEWLINE statements END

    FUNCTION        shift and go to state 140


state 132

    (53) from -> FROM expression TO expression error FUNCTION NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 141
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 133

    (49) from -> FROM expression error expression WITH STEP expression DO . FUNCTION NEWLINE statements END

    FUNCTION        shift and go to state 142


state 134

    (50) from -> FROM expression error expression DO FUNCTION NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 143
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 135

    (35) from -> FROM expression TO expression DO FUNCTION NEWLINE statements END .

    NEWLINE         reduce using rule 35 (from -> FROM expression TO expression DO FUNCTION NEWLINE statements END .)
    SEMICOLON       reduce using rule 35 (from -> FROM expression TO expression DO FUNCTION NEWLINE statements END .)


state 136

    (48) from -> FROM expression TO expression DO FUNCTION error statements END .

    NEWLINE         reduce using rule 48 (from -> FROM expression TO expression DO FUNCTION error statements END .)
    SEMICOLON       reduce using rule 48 (from -> FROM expression TO expression DO FUNCTION error statements END .)


state 137

    (52) from -> FROM expression TO expression DO error NEWLINE statements END .

    NEWLINE         reduce using rule 52 (from -> FROM expression TO expression DO error NEWLINE statements END .)
    SEMICOLON       reduce using rule 52 (from -> FROM expression TO expression DO error NEWLINE statements END .)


state 138

    (37) from -> FROM expression TO expression WITH STEP expression DO FUNCTION . NEWLINE statements END
    (47) from -> FROM expression TO expression WITH STEP expression DO FUNCTION . error statements END

    NEWLINE         shift and go to state 144
    error           shift and go to state 145


state 139

    (51) from -> FROM expression TO expression WITH STEP expression DO error . NEWLINE statements END

    NEWLINE         shift and go to state 146


state 140

    (54) from -> FROM expression TO expression WITH STEP expression error FUNCTION . NEWLINE statements END

    NEWLINE         shift and go to state 147


state 141

    (53) from -> FROM expression TO expression error FUNCTION NEWLINE statements END .

    NEWLINE         reduce using rule 53 (from -> FROM expression TO expression error FUNCTION NEWLINE statements END .)
    SEMICOLON       reduce using rule 53 (from -> FROM expression TO expression error FUNCTION NEWLINE statements END .)


state 142

    (49) from -> FROM expression error expression WITH STEP expression DO FUNCTION . NEWLINE statements END

    NEWLINE         shift and go to state 148


state 143

    (50) from -> FROM expression error expression DO FUNCTION NEWLINE statements END .

    NEWLINE         reduce using rule 50 (from -> FROM expression error expression DO FUNCTION NEWLINE statements END .)
    SEMICOLON       reduce using rule 50 (from -> FROM expression error expression DO FUNCTION NEWLINE statements END .)


state 144

    (37) from -> FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 149
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 145

    (47) from -> FROM expression TO expression WITH STEP expression DO FUNCTION error . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 150
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 146

    (51) from -> FROM expression TO expression WITH STEP expression DO error NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 151
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 147

    (54) from -> FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 152
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 148

    (49) from -> FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE . statements END
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statements                     shift and go to state 153
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 149

    (37) from -> FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 154
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 150

    (47) from -> FROM expression TO expression WITH STEP expression DO FUNCTION error statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 155
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 151

    (51) from -> FROM expression TO expression WITH STEP expression DO error NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 156
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 152

    (54) from -> FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 157
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 153

    (49) from -> FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements . END
    (3) statements -> statements . statement
    (5) statement -> . empty eoe
    (6) statement -> . variable eoe
    (7) statement -> . assignment eoe
    (8) statement -> . from eoe
    (9) statement -> . if eoe
    (10) statement -> . function eoe
    (11) statement -> . function_call eoe
    (12) statement -> . command eoe
    (16) empty -> .
    (18) variable -> . NAME index
    (19) variable -> . NAME LBRACKET index RBRACKET
    (17) assignment -> . variable ASSIGNMENT expression
    (46) assignment -> . variable ASSIGNMENT error
    (35) from -> . FROM expression TO expression DO FUNCTION NEWLINE statements END
    (36) from -> . FROM expression TO expression function_call
    (37) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (38) from -> . FROM expression TO expression WITH STEP expression function_call
    (47) from -> . FROM expression TO expression WITH STEP expression DO FUNCTION error statements END
    (48) from -> . FROM expression TO expression DO FUNCTION error statements END
    (49) from -> . FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END
    (50) from -> . FROM expression error expression DO FUNCTION NEWLINE statements END
    (51) from -> . FROM expression TO expression WITH STEP expression DO error NEWLINE statements END
    (52) from -> . FROM expression TO expression DO error NEWLINE statements END
    (53) from -> . FROM expression TO expression error FUNCTION NEWLINE statements END
    (54) from -> . FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END
    (40) if -> . IF logic_expr function_call
    (41) if -> . IF logic_expr DO FUNCTION NEWLINE statements END
    (55) if -> . IF logic_expr DO FUNCTION error statements END
    (56) if -> . IF logic_expr DO error NEWLINE statements END
    (57) if -> . IF error DO FUNCTION NEWLINE statements END
    (58) if -> . IF error function_call
    (59) if -> . IF logic_expr error FUNCTION NEWLINE statements END
    (45) function -> . FUNCTION NAME NEWLINE statements END
    (60) function -> . FUNCTION NAME error statements END
    (61) function -> . error NAME NEWLINE statements END
    (39) function_call -> . DO NAME
    (2) command -> . CMD DIRECT

    END             shift and go to state 158
    NEWLINE         reduce using rule 16 (empty -> .)
    SEMICOLON       reduce using rule 16 (empty -> .)
    NAME            shift and go to state 12
    FROM            shift and go to state 14
    IF              shift and go to state 17
    FUNCTION        shift and go to state 16
    error           shift and go to state 13
    DO              shift and go to state 15
    CMD             shift and go to state 18

    statement                      shift and go to state 19
    empty                          shift and go to state 4
    variable                       shift and go to state 5
    assignment                     shift and go to state 6
    from                           shift and go to state 7
    if                             shift and go to state 8
    function                       shift and go to state 9
    function_call                  shift and go to state 10
    command                        shift and go to state 11

state 154

    (37) from -> FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END .

    NEWLINE         reduce using rule 37 (from -> FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END .)
    SEMICOLON       reduce using rule 37 (from -> FROM expression TO expression WITH STEP expression DO FUNCTION NEWLINE statements END .)


state 155

    (47) from -> FROM expression TO expression WITH STEP expression DO FUNCTION error statements END .

    NEWLINE         reduce using rule 47 (from -> FROM expression TO expression WITH STEP expression DO FUNCTION error statements END .)
    SEMICOLON       reduce using rule 47 (from -> FROM expression TO expression WITH STEP expression DO FUNCTION error statements END .)


state 156

    (51) from -> FROM expression TO expression WITH STEP expression DO error NEWLINE statements END .

    NEWLINE         reduce using rule 51 (from -> FROM expression TO expression WITH STEP expression DO error NEWLINE statements END .)
    SEMICOLON       reduce using rule 51 (from -> FROM expression TO expression WITH STEP expression DO error NEWLINE statements END .)


state 157

    (54) from -> FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END .

    NEWLINE         reduce using rule 54 (from -> FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END .)
    SEMICOLON       reduce using rule 54 (from -> FROM expression TO expression WITH STEP expression error FUNCTION NEWLINE statements END .)


state 158

    (49) from -> FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END .

    NEWLINE         reduce using rule 49 (from -> FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END .)
    SEMICOLON       reduce using rule 49 (from -> FROM expression error expression WITH STEP expression DO FUNCTION NEWLINE statements END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 22 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 65 resolved as shift
WARNING: shift/reduce conflict for AND in state 65 resolved as shift
WARNING: shift/reduce conflict for OR in state 65 resolved as shift
WARNING: shift/reduce conflict for CMP in state 65 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 78 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 78 resolved as shift
WARNING: shift/reduce conflict for AND in state 78 resolved as shift
WARNING: shift/reduce conflict for OR in state 78 resolved as shift
WARNING: shift/reduce conflict for CMP in state 78 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 79 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 79 resolved as shift
WARNING: shift/reduce conflict for AND in state 79 resolved as shift
WARNING: shift/reduce conflict for OR in state 79 resolved as shift
WARNING: shift/reduce conflict for CMP in state 79 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 80 resolved as shift
WARNING: shift/reduce conflict for AND in state 80 resolved as shift
WARNING: shift/reduce conflict for OR in state 80 resolved as shift
WARNING: shift/reduce conflict for CMP in state 80 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 81 resolved as shift
WARNING: shift/reduce conflict for AND in state 81 resolved as shift
WARNING: shift/reduce conflict for OR in state 81 resolved as shift
WARNING: shift/reduce conflict for CMP in state 81 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 82 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 82 resolved as shift
WARNING: shift/reduce conflict for AND in state 82 resolved as shift
WARNING: shift/reduce conflict for OR in state 82 resolved as shift
WARNING: shift/reduce conflict for CMP in state 82 resolved as shift
